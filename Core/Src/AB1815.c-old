/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file    AB1815.c
 * @brief   AB1815 drivers
 ******************************************************************************
 * @attention
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"
#include "AB1815_A.h"
#include <stdbool.h>

extern I2C_HandleTypeDef hi2c1;
extern SPI_HandleTypeDef hspi1;

static inline uint32_t utils_enter_critical_section(void);
static inline void utils_exit_critical_section(uint32_t primask_bit);

/*
 * The device is accessed at addresses 0xD2/D3,
 * 7-bit address is transmitted MSB first.
 * eighth bit indicate a write (RW = 0) or a read (RW = 1)
 */

uint8_t i2cReadAddr = 0xD3;
uint8_t i2cWriteAddr = 0xD2;

bool detectChip()
{
    bool bResult, finalResult = false;
    uint8_t value = 0;

    // FOUT/nIRQ  will go HIGH when the chip is ready to respond

    unsigned long start = HAL_GetTick();
    bool ready = false;
    while (HAL_GetTick() - start < 1000)
    {
        if (HAL_GPIO_ReadPin(NIRQ_GPIO_Port, NIRQ_Pin) == GPIO_PIN_SET) // B12
        {
            ready = true;
            break;
        }
        if (!ready)
        {
            printf("FOUT did not go HIGH\n");
            // May just want to return false here
        }
    }

    bResult = readRegister(REG_ID0, value, 1); // REG_ID0 = 0x28, the upper RW bit indicating read (if 0) or write (if 1).
    if (bResult && value == REG_ID0_AB18XX)
    {
        bResult = readRegister(REG_ID1, value, 1);
        if (bResult && value == REG_ID1_ABXX05)
        {
            finalResult = true;
        }
    }
    if (!finalResult)
    {
        printf("not detected\n");
    }

    return finalResult;
}

bool readRegister(uint8_t regAddr, uint8_t value, bool lock)
{
    return readRegisters(regAddr, &value, 1, lock);
}

bool readRegisters(uint8_t regAddr, uint8_t *array, uint8_t num, bool lock)
{
    bool bResult = false;
    uint32_t primask_bit;

    if (lock)
    {
        primask_bit = utils_enter_critical_section();
    }

    /**
     * @brief  Transmit and Receive an amount of data in blocking mode.
     * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
     *               the configuration information for SPI module.
     * @param  pTxData pointer to transmission data buffer
     * @param  pRxData pointer to reception data buffer
     * @param  Size amount of data to be sent and received
     * @param  Timeout Timeout duration
     * @retval HAL status
     */
    // HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    // HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    // 8-bit Address byte the upper RW bit indicating read (if 0) or write (if 1).
    uint8_t regAdd = regAddr | 0x80;
    RTC_L();
    if (HAL_SPI_TransmitReceive(&hspi1, &(regAdd), 1, 1000) != HAL_OK)
    {
        Error_Handler();
    }

    // HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    if (HAL_SPI_Receive(&hspi1, array, num, 3000) != HAL_OK)
    {
        Error_Handler();
    }

    RTC_H();
    bResult = true;

    if (lock)
    {
        utils_exit_critical_section(primask_bit);
    }
    return bResult;
}

uint8_t readRegister_value(uint8_t regAddr, bool lock)
{
    uint8_t value = 0;

    (void)readRegister(regAddr, value, lock);

    return value;
}

bool writeRegister(uint8_t regAddr, uint8_t value, bool lock)
{
    return writeRegisters(regAddr, &value, 1, lock);
}

bool writeRegisters(uint8_t regAddr, uint8_t *array, size_t num, bool lock)
{
    bool bResult = false;
    uint32_t primask_bit;

    if (lock)
    {
        primask_bit = utils_enter_critical_section();
    }

    /**
     * @brief  Transmit an amount of data in blocking mode.
     * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
     *               the configuration information for SPI module.
     * @param  pData pointer to data buffer
     * @param  Size amount of data to be sent
     * @param  Timeout Timeout duration
     * @retval HAL status
     */
    // HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)

    if (HAL_SPI_Transmit(&hspi1, &regAddr, 1, 3000) != HAL_OK)
    {
        Error_Handler();
    }

    if (HAL_SPI_Transmit(&hspi1, array, num, 3000) != HAL_OK)
    {
        if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_NONE) // HAL_I2C_ERROR_NONE
        {
            Error_Handler();
        }
    }

    if (lock)
    {
        utils_exit_critical_section(primask_bit);
    }
    return bResult;
}

bool maskRegister(uint8_t regAddr, uint8_t andValue, uint8_t orValue, bool lock)
{
    bool bResult = false;
    uint32_t primask_bit;
    if (lock)
    {
        primask_bit = utils_enter_critical_section();
    }

    uint8_t value = 0;

    bResult = readRegister(regAddr, value, 1);
    if (bResult)
    {
        uint8_t newValue = (value & andValue) | orValue;

        if (newValue != value)
        {
            bResult = writeRegister(regAddr, newValue, 1);
        }
    }

    if (lock)
    {
        utils_exit_critical_section(primask_bit);
    }
    return bResult;
}

// ************************ critical *****************************************

static inline uint32_t utils_enter_critical_section(void)
{
    uint32_t primask_bit = __get_PRIMASK();
    __disable_irq();
    return primask_bit;
}

static inline void utils_exit_critical_section(uint32_t primask_bit)
{
    __set_PRIMASK(primask_bit);
}

time_t get()
{
    ab1815_tmElements_t tm;
    get_time(&tm);
    return makeTime(tm);
}

// 0x00
void set(time_t time)
{
    ab1815_tmElements_t tm;
    breakTime(time, tm);
    set_time(&tm);
}